## Pandas 기본 사용법

### Pandas란?

- 데이터를 효과적으로 처리하고, 보여줄 수 있도록 도와주는 라이브러리
- Numpy와 함께 사용되어 다양한 연계적인 기능을 제공
- 인덱스에 따라 데이터를 나열하므로 사전 자료형에 가깝다.
- 시리즈를 기본적인 자료형으로 사용(시리즈 == 인덱스와 값으로 구성됨)
-  numpy기반 라이브러리로 구조화된 데이터를 효과적으로 처리하고 저장할 수 있는 파이썬 라이브러리
- Array 계산에 특화된 numpy를 기반으로 만들어져서 다양한 기능들을 제공함. 
- series data/ data frame



### Series란?

- 특수한 dictionary
- numpy array가 보강된 형태로 Data에 Index를 추가해서 가지고 있음.


> 인덱스로 접근 가능하며 지정해 줄 수 있음. 
>
> Series([1,2,3,4])를 통해서 1,2,3,4를 리스트에 넣어주고 index=['a','b','c','d'] 를 통해 각가의 데이터에 해당하는 인덱스를 지정해줌. 

> 딕셔너리로 series 만들기 딕셔너리의 키값은 index로 들어가고 value값은 data 값이 됌.



``` python
import pandas as pd

array = pd.Series(['사과', '바나나', '당근'], index=['a', 'b', 'c']])
print(array)
print(array['a'])
```

``` python
import pandas as pd

# Dict 자료형을 Series로 바꾸기
data = {
    'a': '사과',
    'b': '바나나',
    'c': '당근',
}
array = pd.Series(data)
print(array['a'])
```



### 데이터 프레임이란?

- 다수의 시리즈를 모아 처리하기 위한 목적으로 사용함
- 표 형태로 데이터를 손쉽게 출력하고자 할 때 사용함
- 여러개의 series가 모여서 행과 열을 이룬 데이터

> 위에서 만든 population series 넣음.

> 파이썬에서 문자열은 기본적으로object로 봄.

> 1인당 GDP 만들어 보기

> 만든 데이터 프레임을 여러 형태의 파일로 저장가능
>
> CSV : Comma Sperated Values 으로 `,`로 구분되는 데이터



#### 데이터 프레임 사용하기

``` python
import pandas as pd

word_dict = {
    'Apple': '사과',
    'Banana': '바나나',
    'Carrot': '당근',
}
frequency_dict = {
    'Apple': 3,
    'Banana': 5,
	'Carrot': 7,
}
word = pd.Series(word_dict)
frequency = pd.Series(frequency_dict)
summary = pd.DataFrame([
    'word': word,
    'frequency': frequency
])

print(summary)
```

- Indexing과 Slicing

  - loc : 명시적인 인덱스를 참조하는 방식

    > country.loc['china'] 로 참조함. 오른쪽 표에서 해당 정보와 이름, 타입출력.

    > country.loc['japan:korea', :'population'] 은 japan에서 korea까지 데이터를 뽑을 건데 population 컬럼까지만 뽑아달라는 의미.(앞에 비워둔거 보니 처음부터를 의미하고 처음은 gdp)

  - iloc: 파이썬 스타일 정수 인덱스를 참조하는 방식. 

    > 여기서 인덱스는 앞에서부터 순서대로 정해짐. 그리고 당연히 [1:3] 일때 3은 포함하지 않음. 그래서 1부터 2까지임.

- DataFrame 새 데이터 추가/수정하기

  - 리스트로 추가하기, 딕셔너리로 추가하기

    > 첫번째 줄은 이름, 나이, 주소 라는 컬럼을 가진 DataFrame을 만들어 dataframe이라는 변수에 저장함.
    >
    > 두번째 줄은 리스트로 데이터를 추가하는 방식.
    >
    > 세번째 줄은 딕셔너리로 추가하는 방법.
    >
    > 네번째 줄은 데이터 수정.

- DataFrame 새 컬럼 추가

  > nan : Not a Number 으로 숫자가 아닌 데이터라는 의미, 값이 비어있는 데이터를 지칭함. (null과 같은 의미 인듯.)
  >
  > 여기서는 '전화번호'컬럼에 nan을 추가 해달라는 의미.

  > 두번째 줄을 보면 0번 index에 전화번호 컬럼에 '01012341234'를 넣어라

  > 세번째 줄을 보면 len을 쓰는데 몇개의  dataframe을 가지고 있나 보는 것. 

- 컬럼을 이용해서 데이터 선택하기

  - 컬럼 이름이 하나만 있다면 Serise

  - 리스트로 들어가 있다면 DataFrame, 특정컬럼만 뽑아서 DataFrame으로 만들어 주고 싶을때 쓰임. 

    >  저기 리스트에서 쓴 순서대로 해당 컬럼 데이터를 가져옴. 여기서는 이름, 주소, 나이로 쓰니까 그 순서대로 나옴. 

- 누락된 데이터 체크

  - 튜토리얼에서 보는 데이터와 달리 현실의 데이터는 누락되어 있는 형태가 많음.

  - `isnull()` 은 데이터가 비어있는지 확인하는 함수, 비어있으면 True 반환.

  - `notnull()`은 비어있지 않은 경우에 대해서 True 를 반환함.

    > 아래 데이터 프레임에 대해서 `isnull`, `notnull` 한 경우

> 누락된 데이터를 체크하는 걸 넘어서서 제거하기 위해서 `dropan()` 또는 채워넣기 위해서 `fillna()`를 씀.

> 첫번째 줄은 영희의 전화번호가 nan으로 비어 있으니까 해당 인덱스 데이터가 다 제거됌.

> 두번째 줄은 dataframe['전화번호'].fillna('전화번호 없음') 전화번호 컬럼에서 비어있으면 '전화번호 없음'으로 채워 주세요를 의미하는데 이렇게 하면  series 데이터로 나올텐데 이것을 다시 dataframe에 전화번호 컬럼에 넣어달라는 걸 의미함. 

- Series 연산

  - numpy array에서 사용했던 연산자들을 활용할 수 있음. 

    > 세번째 줄은 인덱스가 0인 것끼리 더해야 하는데 B에는 인덱스가  0인 데이터가 없음. 따라서 더해줄 수 없으니까 NaN을 반환. 인덱스가 3인 경우도 마찬가지. 둘다 해당 인덱스가 있어야 연산한 값을 반환함.

    > 네번째 줄 의미는 A에 B를 더하는 데 `fill_value` 을 값을 주면 해당 인덱스가 없을때 `fill_value`을 채워 연산을 함.

- DataFrame 연산

  > 첫번째 줄에서 randint(0,10,(2,2)) 의미가 0부터 10까지의 정수 중 랜덤하게 뽑아서 2*2 행렬을 만들어라. 그리고 컬럼값을 list로 A, B로 넣어라.

  > 더하기를 하는데 같은 이름을 가진 컬럼의 데이터끼리 더함.  A 데이터에서 인덱스가 0이고 컬럼 이름이 A인 2와 B 데이터에서 인덱스가 0이고 컬럼 이름이 A인 2와 더해서 4를 반환함. 

  > A+B를 했을때는 한쪽 데이터에 같은 인덱스와 컬럼이 없는 경우 NaN을 반환함.

- 집계함수

  - numpy array에서 사용했던 sum, mean등을 활용할 수 있다.

    > 세번째 줄은 A 라는 이름을 가진 컬럼. 즉, 해당 series를 모두 더해라. 

- 값으로 정렬하기

  > `sort_values()`을 이용해서 정렬할 것임. 아래는 정렬하기 전에 만든 dataframe

  > 함수에 컬럼을 인자로 받아서 해당 컬럼을 정렬함. 기본적으로 오름차순으로 정렬됌. (값을 기준으로 순서가 바뀌고 정렬됌. 인덱스 바뀐 것 확인)

  > 내림차순으로 정렬할때는 `ascending=False` 를 주면 됌.

  > 두개의 컬럼값을 리스트로 넣어서 정렬하면, 앞에것 먼저 정렬후에 두번째것을 정렬함. 예를 들어서 여기서 col2가 먼저 이므로 col2에 대해서 오름차순으로 정렬을 함. 그리고 이후 col1을 기준으로 정렬하는데 col2가 같은 경우에 대해서 정렬을 함. col2에서 A인 값이 두개임. 이 두개를 col1에서 1과 2를 정렬함. 

- 조건으로 검색하기

  - Numpy array와 마찬가지로 masking 연산이 가능함. 

    > numpy, pandas 라이브러리를 각각 np, pd 이름으로 가져옴.
    >
    > df 란 dataframe을 만들어 주고 A컬럼 중에 0.5 이하인 것을 출력하면 
    >
    > 오른쪽과 같은 series가 나옴. 

  - 조건에 맞는 DataFrame row를 추출 가능함.

    > 세번째 줄 `df["A"] < 0.5` 만 쓰면 결과가 1) 처럼 series 형태로 나오게 됌.  그리고 `df["B"] > 0.3` 으로 쓰면 2) 처럼 1)과 같은 series 형태로 출력됌. 따라서 df[] 로 감싸줘 Dataframe에 masking 현상을 적용해야 3)처럼 출력됌.  아니면 serise 형태로 출려됌.

    > 네번째 줄처럼 query를 써서 줄글로 연산하는 것도 가능함.  세번째 줄에서 and는 &으로 써야하는 듯. 세번째와 네번째 줄은 같은기능을 함.

  - 문자열이라면 다른 방식으로도 조건 검색이 가능.

    > 첫번째 줄은 Cat이라는 문자열을 포함하면 True 아니면 False를 반환함. 

    > 두번째 줄은 Cat이라는 문자열과 정확히 일치하면 True 아니면 False를 반환함.  `df["Animal"] == "Cat" `처럼 쓸 수도 있음.

    > 정규표현식을 통해서 좀 더 문자열을 강력하게 검색할 수 있다고 함. 이건 찾아보라고 함. 

     

- 함수로 데이터 처리하기 

  - apply를 통해서 함수로 데이터를 다룰 수 있음.

    > 복잡한 연산을 하기 위해서 어떤 데이터를 받아 가공하고 가공된 값을 다시 데이터로 넣어주기 위해서 함수를 짜서 처리해야 되는 데 이때 apply를 씀. (다른 곳이랑 다르게 설명이 한 화면에 안 나와 밑에 자세히 씀.)

    > 첫번째 줄을 통해서  아래와 같은 dataframe이 만들어짐.


> 두번째 세번째 줄을 통해서 square 라는 함수를 만들고 제곱한 값을 반환함.

> 네번째 줄에서 apply를 사용하는데 이때 함수를 인자로 받음. 여기서는 square를 받음.  그러면 아래처럼 결과를 series 형태로 출력함. 

> 따라서 아까 dataframe에 추가하기위해서는  `df["square"]=df["Num"].apply(square)` 로 코드 작성해야함.  아래처럼 추가되어 출력됌.

> lambda를 이용할수도 있음. `x:x**2`의 의미는 x값을 받아 x**2을 실행하고 반환.
>
> `df["square"]=df.Num.apply(lambda x :x**2) `로 써줘 반환되는 값을 square 컬럼에 넣어줌. (`df["square"]=df["Num"].apply(square)` 와 같은 기능)



- apply를 통해서 함수로 데이터 다루는 다른 예시 1

  - 일정하지 않은 번호들을 숫자로 동일하게 변경하는 게 목표임.


> 아래와 같은 딕셔너리로 만들고 반복문을 돌면서 확인하고 replace를 통해서 key에 해당하는 값들을 value 값들로 바꿔  phone에 넣고 반환.

> 이후에 apply를 써서 함수를 인자로 받아 실행하고 preprocess_phone 컬럼에 집어넣음.

- 함수로 데이터 다루는 다른 예시 2

  - replace : apply 기능에서 데이터 값만을 대체하고 싶을때

  - 위에 처럼 데이터를 변경하는 함수를 짜고 apply에서 인자로 받아서 하는 게 아니라 데이터 값만들 바꾸고 싶을때 replace를 사용함. 

    > 변경될 값을 key로 변경하고 싶은 값을 value로 넣어서 딕셔너리 만들어줌.  첫번째 줄을 실행하면 1)과 2) 가운데 처럼 series 형태로 반환이 되고 이후 sex 컬럼에 다시 넣어주면 2)처럼 변경됌. 

> 위에 처럼 series로 받고 직접 넣어줘서 변경하고 싶은게 아니라 바로 dataframe에 적용시켜 2)처럼 바로 변경되길 원한다면 `inplace=True`로 주면 됌.  (inplace 혹시 replace에만 있는 속성인가? 알아보자 이전 강의에서 계속 series로 받고 이걸 다시 넣어주는 데 안그래도 될 상황이 더 많을 거 같음.)

- 그룹으로 묶기

  - 간단한 집계를 넘어서서 조건부로 집계하고 싶은 경우

    > 첫번째 두번째 줄 코드를 통해서 df에 key, data1, data2를 채움. 
    >
    > 세번째 줄 `groupby('key')` 에서 key값을 통해 묶어줌. 즉, 동일한 key값끼리 묶어줌. A는 A끼리 B는 B끼리, 이 코드를 통해서 일단 묶어서 가지고만 있음. 

    > 이후 네번째 줄을 통해서 어떤 연산을 실행함. 여기서는 sum인데  2) 이 그 결과임. key가 A인 것끼리 data1를 더하고 이를 data1 컬럼에 넣음.  

    > 다섯번째 줄 처럼 key, data1을 동시에 묶을 수 있음. 

- aggreate

  - groupby를 통해서 집계를 한번에 계산하는 방법

    > 첫번째 줄은 `groupby('key')` 를 통해서 key를 기준으로 묶고 `aggregate(['min', np.median, max])`를 통해서 묶인 값들을 서로 비교해서 최소값, 중간값, 최대값을 해당 컬럼을 만들고 값을 입력함.  (근데 왜 표현하는게 다르지 'min은 min' 이거인데 max는 왜 그냥 max일까? 그냥 문법 같기도 하고 )

    > 2) 보면 data1, data2로 크게 컬럼으로 나눠져 있고 그 밑에 min, median, max가 반복됌. 이런것을 멀티인덱스라고 부름. 

    > 두번째 줄을 실행하면 3)처럼 출력되는데 key를 기준으로 grouping 하고 data1 컬럼에는 최소값을 data2에는 sum을 하고 넣음. (이렇게 하면 컬럼마다 어떤 연산을 할지 정해줄 수 있으.있음.)

    > 첫번째 줄처럼 만들려면 리스트를 쓰고 두번째 줄 처럼 할때는 딕셔너리 써야하는 듯.

- filter

  - groupby를 통해서 그룹 속성을 기준으로 데이터 필터링

    > 세번째 줄 실행하면 key값으로 묶고 평균값을 반환함. 2) 표처럼 출력됌.

    > 네번째 줄을 실행하면 key값으로 묶고 filter 를 통해서 위해서 만든 함수를 인자로 받아 실해함. 함수는 x의 data2 컬럼의 평균값을 구하고 해당 값이 3을 넘으면 반환함. 
    >
    > 2) 표를 보면 key가 B, C인 값들이 3을 넘음 따라서 1)에서 B,C 모두를 반환함. 이때 인덱스 순으로 반환함. 0, 3 없는 건 A인게 빠져서 그럼. 

- apply

  - groupby를 통해서 묶인 데이터에 함수 적용

    > key를 기준으로 묶고 lambda를 이용해서 최대값에서 최소값을 빼줌. 

- get_group

  - groupby로 묶인 데이터에서 key값으로 데이터를 가져올 수 있다.

    > groupby로 묶은 데이터 중에서 필요한 값을 뽑아올때 씀. 세번째 줄 경우 시도를 기준으로 묶고 그 중에서 충남에 해당하는 데이터만 가져와라는 의미.
    >
    > 네번째 줄은 그 해당 데이터가 총 몇개인지 알아볼때 쓰임.

- MultiIndex

  - 인덱스를 계층적으로 만들 수 있다. 

    > index를 2차원 배열 형태로 집어넣음. ['A','A','B','B'] 가 순서가 더 높음으로 A와 B가 각각 하나로 묶을 것임.

  - 열 인덱스도 계층적으로 만들 수 있다. 

  - 다중 인덱스 컬럼의 경우 인덱싱은 계층적으로 한다. 인덱스 탐색의 경우에는 loc, iloc를 사용가능하다. 

    > 첫번째 줄을 시행하면 1)처럼 A 전체가 출력되고 두번째 줄을 실행하면 2)처럼 A의 1번 컬럼만 출력이 됌.  리스트 접근하는 거랑 비슷한듯 하다.  

    

- pivot_table

  - 데이터에서 필요한 자료만 뽑아서 새롭게 요약, 분석할 수 있는 기능.

  - 엑셀에서의 피봇 테이블과 같은 기능.

  - index는 행 인덱스로 들어갈 key값.

  - column에 열 인덱스로 라베링될 값.

  - value에 분석할 데이터.

    > 아래와 같은 테이블을 만들었다고 가정하고 밑에 설명 이어나감. 

  - 위의 데이터를 활용해서 성별과 좌석별 생존률 구하기

    > 컬럼 명으로 class가 오고 성별 데이터가 인덱스로 옴. 각의 데이터들, 첫번째줄은 성별이 female일때 class별 생존률의 평균을 나타냄. 

    > 이때 value값을 어떻게 채울지 정해주는게 aggfunc임. np.mean을 통해서 평균값을 채우겠다는 의미

  - 예시 2

    >index는 월별로 컬럼은 내역으로 정해지고 데이터 값들은 수입, 지출 내역으로 채워짐.